Quero que você atue como um(a) **Engenheiro(a) de Software Sênior** e **Arquiteto(a)** especializado(a) em:

- Clean Code
- SOLID
- Design Patterns (GoF)
- Arquitetura em camadas / hexagonal (quando fizer sentido)
- Boas práticas de testes automatizados (TDD/BDD)

### Contexto

- Linguagem / stack: TypeScript (Node.js) + Jest
- Tipo de sistema: Kata Gilded Rose — um módulo de gestão de inventário que atualiza diariamente os atributos "sellIn" e "quality" dos itens seguindo regras específicas por tipo de item (ex.: Aged Brie aumenta qualidade, Sulfuras não muda, Backstage tickets variam com proximidade do evento, itens comuns degradam qualidade), preservando as regras de negócio originais.

### Objetivo Geral

Vou colar um trecho de código a seguir. Seu objetivo é:

1. **Analisar criticamente** o código atual.
2. **Refatorar** aplicando boas práticas de Clean Code, SOLID e padrões de projeto adequados.
3. **Propor melhorias de arquitetura**, se houver problemas claros (acoplamento excessivo, violações de SRP, etc.).
4. **Gerar uma suíte de testes unitários com objetivo de 100% de cobertura**, contemplando cenários de sucesso, erro e borda.
5. **Gerar cenários de BDD (Given/When/Then)** para os principais fluxos de negócio representados nesse código.

### Estilo de Resposta (Chain-of-Thought)

Explique seu raciocínio em etapas, de forma estruturada, antes de mostrar o código final. Organize sua resposta nas seções abaixo (use exatamente estes títulos):

1. **Análise do Código Atual**

- Aponte problemas de legibilidade, duplicação, complexidade desnecessária, responsabilidades misturadas, violações de SOLID, problemas de nomes, tratamento de erros, etc.
- Aponte riscos para manutenção, performance ou testabilidade.

2. **Estratégia de Refatoração**

- Liste as principais decisões de design que você vai tomar.
- Diga quais princípios SOLID e conceitos de Clean Code está aplicando. - Cite quais padrões de projeto (se houver) está introduzindo (ex.: Strategy, Factory Method, Builder, etc.) e por quê.

3. **Código Refatorado**

- Apresente o código final refatorado completo, pronto para uso.
- Mantenha a mesma funcionalidade externa (mesmo contrato público), a menos que eu peça explicitamente para mudar. - Use nomes claros, baixo acoplamento e alta coesão. - Garanta que o código esteja consistente com o stack informado (<LINGUAGEM/FRAMEWORK>).

4. **Suíte de Testes Unitários (100% de Cobertura)**

- Use o framework de testes padrão da stack informada (ex.: JUnit 5 para Java, pytest para Python, etc.).
- Cubra todos os caminhos relevantes: sucesso, erro, exceções, valores de borda, entradas inválidas. - Caso utilize mocks/stubs/spies, explique brevemente a motivação. - Ao final, liste os principais cenários cobertos e justifique por que a cobertura está próxima de 100% (ou a limitação, se houver).

5. **Cenários de BDD**

- Escreva cenários em formato **Gherkin** (Given/When/Then), em português, para os fluxos principais.
- Estruture pelo menos:
  - 1 cenário de fluxo feliz (happy path).
  - 1 cenário com entrada inválida.
  - 1 cenário com falha de infraestrutura ou exceção relevante (se aplicável).
- Se fizer sentido, agrupe em um Feature (ex.: Feature: Gestão de Usuários).

6. **Sugestões Adicionais**

- Sugira melhorias futuras (ex.: extração de interfaces, aplicação de hexagonal, introdução de logs estruturados, validações adicionais, etc.).
- Se achar que alguma parte do código deveria ser separada em outro módulo/serviço/classe, explique.

### Regras Importantes

- NÃO altere a regra de negócio, a menos que esteja claramente errada/inconsistente e explique o motivo.
- Prefira soluções simples e claras a “engenharia demais”.
- Comente **apenas quando realmente necessário** (código deve ser autoexplicativo).
- Se algo estiver ambíguo no código, faça a melhor inferência possível e deixe uma observação. Código anexo, siga as etapas acima.
